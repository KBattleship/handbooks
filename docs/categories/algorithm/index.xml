<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithm on Quinn</title>
    <link>https://touch-star.com/categories/algorithm/</link>
    <description>Recent content in Algorithm on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Jan 2021 01:13:47 +0800</lastBuildDate>
    
	<atom:link href="https://touch-star.com/categories/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[ Interview ] 2.面试之Boss</title>
      <link>https://touch-star.com/post/algorithm/ext/2_boss_company_2021_01_08/</link>
      <pubDate>Fri, 08 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/2_boss_company_2021_01_08/</guid>
      <description>面试之Boss 1.笔试  删除UserList中年龄大于20的User对象。
 1 2 3 4 5 6 7  // User实体类 public class User{ private Integer age; public Integet getAge(){ return this.age; } }   解题思路：
此题按照最简单的lambda方式进行解答(JDK8才支持)
1 2 3 4 5 6  public class Main{ public static void remove(List&amp;lt;User&amp;gt; userList){ // removeIf(Predicate&amp;lt;? super E&amp;gt; filter)  userList.removeIf(x -&amp;gt; x != null &amp;amp;&amp;amp; x.getAge() != null &amp;amp;&amp;amp; x.getAge() &amp;gt; 20); } }    从1000W个数中取出最小的10个数，并按照顺序打印。</description>
    </item>
    
    <item>
      <title>[ Interview ] 3.面试</title>
      <link>https://touch-star.com/post/algorithm/ext/3_xueqiu_company_2021_01_09/</link>
      <pubDate>Fri, 08 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/3_xueqiu_company_2021_01_09/</guid>
      <description>面试之XueQiu 1.JVM垃圾回收机制 2.什么是Netty？ 3.Netty粘包/拆包 3.Kubernetes工作原理 4.快排实现原理 BD 1. Hash最终一致性算法   算法目标：
当K个Key的请求时，后台增减节点，只会引起 K/N 的 Key发生重新映射。
 在后台节点稳定时，同一个key的每次请求映射到的节点是一样的。 在后台节点增减时，此算法尽量将 K 个Key映射到之前相同的节点上。    Hash存在问题：
 假定N为后台服务节点数，当前台携带关键字key发出请求时，我们通常将key进行Hash后采用 模运算(hash(key)%N) 来讲请求分发在不同的节点上。 对前台请求于后台无状态服务节点不敏感的场景而言，只要请求key具有一定的随机性，哪怕节点动态增删，该算法对于后台而言一样可以起到很好的负载均衡效果。 但在对于分布式缓存，或者分布式数据这样有状态服务的情况下，上述方式将存在问题。因为后台节点的增删会引起几乎所有的Key的重新映射：  针对分布式缓存而言，均发生cache miss； 针对分布式数据库而言，发生数据错乱的情况，影响都是灾难性的。      判断标准：
 平衡性(Balance)：指哈希的结果能够尽可能分不到所有的缓冲中，这样可以使得所有缓冲空间都得到利用。 单调性(Monotonicity)：单调性是指如果已经有一些内容通过Hash算法分配到了缓冲中，又有新的缓冲加入到系统中，Hash的结果应该能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲。不同的终端可能通过Hash的过程将同样的缓冲内容应设在不同的缓冲中。应尽量降低分散性。 负载(Load)：实际上是另一个角度看待分散性。对于一个特定的缓冲区而言，可能被不同的用户映射到不同的内容。应尽量降低缓冲的负荷。    Hash一致性算法：
 是一个2^32个点组成的Hash圆环 按照 顺时针方向 进行组织 将数据 Key 使用相同的 hash() 计算出Hash值，并确定在此 Hash环 上的位置，从此位置按照 顺时针方式 寻找，碰到的第一台节点将是定位到的节点。    Hash环发生数据倾斜
 在服务节点太少的情况，数据容易发生倾斜 解决办法：  增加虚拟节点，形成均匀的Hash环避免数据倾斜。 通过 Hash(&amp;ldquo;${Node1}#1&amp;rdquo;) 的方式构造成虚拟节点。      2.</description>
    </item>
    
    <item>
      <title>[ Interview ] 1.面试之MateAPP</title>
      <link>https://touch-star.com/post/algorithm/ext/1_mate_app_company_2021_01_07/</link>
      <pubDate>Thu, 07 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/1_mate_app_company_2021_01_07/</guid>
      <description>面试之MateAPP 1.笔试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /** * 给定一个二叉树, 检查它是否是镜像对称的 * 例如以下是镜像对称的 * 1 * / \ * 2 2 * / \ / \ * 3 4 4 3 * * 下面这个则不是镜像对称的 * 1 * / \ * 2 2 * \ \ * 3 3 * * TreeNode类的定义: * * @param TreeNode 一颗二叉树 * @return boolean 是否是对称的 */ // 以下给出TreeNode类, 请勿修改 static class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int x) { val = x; } }   解题思路</description>
    </item>
    
  </channel>
</rss>