<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithm on Quinn</title>
    <link>https://touch-star.com/tags/algorithm/</link>
    <description>Recent content in algorithm on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 08 Jan 2021 01:13:47 +0800</lastBuildDate>
    
	<atom:link href="https://touch-star.com/tags/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[ Interview ] 2. 面试之算法</title>
      <link>https://touch-star.com/post/algorithm/ext/2_algorithm_2021_01_08/</link>
      <pubDate>Fri, 08 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/2_algorithm_2021_01_08/</guid>
      <description>面试之算法 1. 删除UserList中年龄大于20的User对象 1 2 3 4 5 6 7  // User实体类 public class User{ private Integer age; public Integet getAge(){ return this.age; } }   解题思路：
此题按照最简单的lambda方式进行解答(JDK8才支持)
1 2 3 4 5 6  public class Main{ public static void remove(List&amp;lt;User&amp;gt; userList){ // removeIf(Predicate&amp;lt;? super E&amp;gt; filter)  userList.removeIf(x -&amp;gt; x != null &amp;amp;&amp;amp; x.getAge() != null &amp;amp;&amp;amp; x.getAge() &amp;gt; 20); } }   2. 从1000W个数中取出最小的10个数，并按照顺序打印。 解题思路： 首先应该想到堆排序(Top K堆问题)，大根堆(前k小)或小根堆(后k大)。在Java中有已经实现的PriorityQueue，解决此问题将最为简单，复杂度为O(NlogK)。</description>
    </item>
    
    <item>
      <title>[ Interview ] 3. 面试之Java</title>
      <link>https://touch-star.com/post/algorithm/ext/3_base_knowledge_2021_01_09/</link>
      <pubDate>Fri, 08 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/3_base_knowledge_2021_01_09/</guid>
      <description>面试 X_Q 1.JVM垃圾回收机制 Java编程中，程序员不需要刻意显式进行垃圾回收去释放一个对象内存，而是JVM会进行自动垃圾回收。 JVM中存在一个 优先级较低 的线程，只有当 JVM处于空闲 或者 堆空间不足 的情况触发执行。此过程中，将扫描到 没有被引用的对象 防止垃圾回收集合中，进行垃圾回收。
 判断对象是否可以被回收   引用计数器：
 为每一个对象创建一个引用计数器，有引用此对象，计数器进行+1；引用释放后，计数器进行-1。当对象引用计数器 == 0时，说明此对象可以进行回收。(不能解决循环引用问题)    可达性分析算法
 从GC Roots开始向下搜索，走过的搜索路径将形成引用链，当一个对象到 GC Roots不存在任何引用链式，说明此对象可以进行回收。      2.什么是Netty？  见 Netty
 3.Netty粘包/拆包 3.Kubernetes工作原理 4.快排实现原理 B_D 1. Hash最终一致性算法   算法目标：
当K个Key的请求时，后台增减节点，只会引起 K/N 的 Key发生重新映射。
 在后台节点稳定时，同一个key的每次请求映射到的节点是一样的。 在后台节点增减时，此算法尽量将 K 个Key映射到之前相同的节点上。    Hash存在问题：
 假定N为后台服务节点数，当前台携带关键字key发出请求时，我们通常将key进行Hash后采用 模运算(hash(key)%N) 来讲请求分发在不同的节点上。 对前台请求于后台无状态服务节点不敏感的场景而言，只要请求key具有一定的随机性，哪怕节点动态增删，该算法对于后台而言一样可以起到很好的负载均衡效果。 但在对于分布式缓存，或者分布式数据这样有状态服务的情况下，上述方式将存在问题。因为后台节点的增删会引起几乎所有的Key的重新映射：  针对分布式缓存而言，均发生cache miss； 针对分布式数据库而言，发生数据错乱的情况，影响都是灾难性的。      判断标准：</description>
    </item>
    
    <item>
      <title>[ Interview ] 1. 面试之清单</title>
      <link>https://touch-star.com/post/algorithm/ext/1_exam_2021_01_07/</link>
      <pubDate>Thu, 07 Jan 2021 01:13:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/algorithm/ext/1_exam_2021_01_07/</guid>
      <description>面试之MateAPP  加粗加斜 : 为本人面试所遇到重复出现的点儿 加粗 : 为本人面试所遇到的点儿 正常 : 为本人面试刷的面经  一、 Java 1. 集合 2. 多线程  synchronized锁以及锁升级 线程的几种状态以及如何转化的 线程池几个重要参数 线程池拒绝策略  3. JVM 二、 Mysql  讲讲Mysql索引 Mysql索引失效的几种情况 Mysql强制索引 分库分表如何实现的 分库分表中间件  三、 Redis  什么是击穿？什么是雪崩？ Redis支持的几种数据结构 Redis跳表  四、 Spring  SpringIOC SpringAOP SpringBoot循环依赖 SpringBoot订阅发布模式。ApplicationEvent处于什么角色，如何实现的？ JDK动态代理和CGLIB动态代理的区别 SpringAOP常用的切入点 SpringIOC常用注解。 @Autowired与@Resource区别 @Qualifier与@Autowired Springboot上下文切换  五、 分布式 六、 开源框架 1. Netty 2. Dubbo 3. Zookeeper 4. Kafka 5. 七、 设计模式 1.</description>
    </item>
    
  </channel>
</rss>