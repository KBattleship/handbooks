<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>分布式 on Quinn</title>
    <link>https://quinn.touch-star.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link>
    <description>Recent content in 分布式 on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 22 Dec 2020 15:36:27 +0800</lastBuildDate>
    
	<atom:link href="https://quinn.touch-star.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Etcd基础入门(1)</title>
      <link>https://quinn.touch-star.com/post/distributed/2020-04-30-etcd/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://quinn.touch-star.com/post/distributed/2020-04-30-etcd/</guid>
      <description>Etcd架构与实现原理 Etcd是一个用于存储关键数据的键值存储，ZK是一个用于管理配置等信息的中心化服务。ETCD包括 Raft 协议、存储两大模块. etcd 的使用其实非常简单，它对外提供了 gRPC 接口，可以通过 Protobuf 和 gRPC 直接对 etcd 中存储的数据进行管理，也可以使用官方提供的 etcdctl 操作存储的数据。
raft协议 每一个 Raft 集群中都包含多个服务器，在任意时刻，每一台服务器只可能处于 Leader、Follower 以及 Candidate 三种状态中的一种；在处于正常的状态时，集群中只会存在一个 Leader，其余的服务器都是 Follower。
节点选举 使用 Raft 协议的 etcd 集群在启动节点时，会遵循 Raft 协议的规则，所有节点一开始都被初始化为 Follower 状态，新加入的节点会在 NewNode 中做一些配置的初始化，包括用于接收各种信息的 Channel
竞选流程 如果集群中的某一个 Follower 节点长时间内没有收到来自 Leader 的心跳请求，当前节点就会通过 MsgHup 消息进入预选举或者选举的流程。 如果收到 MsgHup 消息的节点不是 Leader 状态，就会根据当前集群的配置选择进入 PreElection 或者 Election 阶段，PreElection 阶段并不会真正增加当前节点的 Term，它的主要作用是得到当前集群能否成功选举出一个 Leader 的答案，如果当前集群中只有两个节点而且没有预选举阶段，那么这两个节点的 Term 会无休止的增加，预选举阶段就是为了解决这一问题而出现的。 当前节点会立刻调用 becomeCandidate 将当前节点的 Raft 状态变成候选人；在这之后，它会将票投给自己，如果当前集群只有一个节点，该节点就会直接成为集群中的 Leader 节点。
如果集群中存在了多个节点，就会向集群中的其他节点发出 MsgVote 消息，请求其他节点投票，在 Step 函数中包含不同状态的节点接收到消息时的响应 如果当前节点投的票就是消息的来源或者当前节点没有投票也没有 Leader，那么就会向来源的节点投票，否则就会通知该节点当前节点拒绝投票。 每当收到一个 MsgVoteResp 类型的消息时，就会设置当前节点持有的 votes 数组，更新其中存储的节点投票状态并返回投『同意』票的人数，如果获得的票数大于法定人数 quorum，当前节点就会成为集群的 Leader 并向其他的节点发送当前节点当选的消息，通知其余节点更新 Raft 结构体中的 Term 等信息</description>
    </item>
    
    <item>
      <title>Etcd基础入门(2)</title>
      <link>https://quinn.touch-star.com/post/distributed/2020-05-14-etcd-basic/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://quinn.touch-star.com/post/distributed/2020-05-14-etcd-basic/</guid>
      <description>1.Etcd 与 Zookeeper 对比  一致性协议:配置共享&amp;amp;服务发现组件的核心基础。  Zookeeper采用ZAB协议(一种类Paxos协议)实现一致性 Etcd采用Raft协议，相比Paxos协议更容易理解，工程化。   API接口: 包含有两个版本V2、V3  V2: 提供HTTP+Json方式调用 V3: 提供grpc方式调用   性能  官方测试数据显示：10000+/s写入(优于Zookeeper性能)   安全  Etcd支持TSL(权限控制优于Zookeeper)    2.Etcd源码结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  (base) {11:45}~/etcd:master ✗ ➭ tree -d -L 1 . .</description>
    </item>
    
    <item>
      <title>Dubbo基础概念</title>
      <link>https://quinn.touch-star.com/post/middleware/dubbo/dubbobase/</link>
      <pubDate>Tue, 22 Dec 2020 15:36:27 +0800</pubDate>
      
      <guid>https://quinn.touch-star.com/post/middleware/dubbo/dubbobase/</guid>
      <description>Dubbo基础概念 1.Dubbo核心组件  Provider： 暴露服务的服务提供方 Consumer： 调用远程服务的消费方 Register： 服务注册与发现注册中心 Monitor： 监控中心和访问调用统计 Container：服务运行时容器  2.Dubbo服务器注册与发现流程  a. Container负责启动，加载，运行服务提供者 b. Provider启动时，向注册中心注册自己并提供服务 c. Consumer启动时，向注册中心订阅自已需调用服务 d. Register返回服务提供者地址列表给服务消费者，如运行期间，服务提供者发生变动，将通过长连接推送至服务消费者 e. Consumer通过负载均衡算法(软方式)，选取注册中心所返回的服务提供者列表中的一个节点进行调用，如果调用失败将尝试其他节点进行调用 f. Consumer、Provider将调用次数、时间记录于内存中，并定时每分钟发送至Monitor监控中心  3.Dubbo项目结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  $ tree -L 1 . ├── dubbo-all ├── dubbo-bom ├── dubbo-build-tools ├── dubbo-cluster # 集群容错模块，涵盖负载均衡策略、集群容错策略及路由 ├── dubbo-common # 通用逻辑模块，提供工具类和通用类型 ├── dubbo-compatible # 兼容性模块 ├── dubbo-config # 配置模块，主要实现API配置、属性配置、XML配置等 ├── dubbo-configcenter # 动态配置中心模块 ├── dubbo-container # 容器运行时，采用Main方法加载Spring容器 ├── dubbo-demo # 三种远程调用方式实例 ├── dubbo-dependencies # ├── dubbo-dependencies-bom ├── dubbo-distribution ├── dubbo-filter # 过滤器 ├── dubbo-metadata # 元数据信息 ├── dubbo-monitor # 监控模块，主要监控接口调用次数及时间等信息 ├── dubbo-plugin # 插件拓展模块 ├── dubbo-registry # 服务发现与注册中心模块 ├── dubbo-remoting # 远程通信模块，为消费者、生产者间提供远程调用能力 ├── dubbo-rpc # 抽象各种通信协议以及动态代理(易混淆remoting) ├── dubbo-serialization   </description>
    </item>
    
  </channel>
</rss>