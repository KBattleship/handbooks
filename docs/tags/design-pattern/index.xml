<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>design pattern on Quinn</title>
    <link>https://touch-star.com/tags/design-pattern/</link>
    <description>Recent content in design pattern on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 22 Aug 2019 15:36:27 +0800</lastBuildDate>
    
	<atom:link href="https://touch-star.com/tags/design-pattern/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>1.迭代器模式</title>
      <link>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_1_iterator/</link>
      <pubDate>Thu, 22 Aug 2019 15:36:27 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_1_iterator/</guid>
      <description>迭代器模式 表1-1 类与接口说明    类名 备注     Aggregate 表示集合的接口   Iterator 遍历集合接口   Book 表示书的类   BookShelf 表示书架的类   BookShelfIterator 遍历书架的类    代码清单  Aggregate接口  1 2 3 4 5 6 7  /** * 表示集合接口 */ public interface Aggregate { /* 用于生成一个遍历集合的迭代器 */ public abstract Iterator iterator(); }    Iterator接口  1 2 3 4 5 6 7 8 9 10 11 12  /** * 遍历集合接口 */ public interface Iterator { /* 判断是否存在下一个元素 */ public abstract boolean hasNext(); /* 获取下一个元素 */ public abstract Object next(); }    Book类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * 表示书的类 */ public class Book { /* 书名属性 */ private String name; /* Default constructor */ public Book(String name) { this.</description>
    </item>
    
    <item>
      <title>2.适配器模式</title>
      <link>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_2_adapter/</link>
      <pubDate>Thu, 22 Aug 2019 15:36:27 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_2_adapter/</guid>
      <description>适配器模式 适配器模式包含两种：  类适配器模式(使用继承的适配器) 对象适配器模式(使用委托的适配器)  适配器模式角色组成：  目标角色 源角色 适配器角色  ①.类适配器模式 继承于源类的同时实现目标接口
表1-1 类与接口说明    类名 备注     Print 表示目标角色   Banner 表示源角色   PrintBanner 表示适配器角色    代码清单  Print(目标角色)  1 2 3 4  public interface Print { abstract void printWeak(); abstract void printStrong(); }    Banner(源角色)  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Banner { private String nameString; public Banner(String nameString) { this.</description>
    </item>
    
    <item>
      <title>3.模板模式</title>
      <link>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_3_template/</link>
      <pubDate>Thu, 22 Aug 2019 15:36:27 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/1-design/1-2-design/1_2_3_template/</guid>
      <description>模板模式 **模板模式：**是带有模板功能的模式，组成模板的方法被定义在父类中，由于这些方法是抽像的，所以在父类代码中无法知道具体实现，唯一能知道的是父类在如何调用这些方法，具体的实现全由子类方法处理。
①.UML图 ②.代码清单  AbstractDisplay类  1 2 3 4 5 6 7 8 9 10 11 12  public abstract class AbstractDisplay { /* 模板类中的模板方法规定了实现的流程,但不做具体抽象方法的具体实现 */ public void display() { open(); print(); close(); } /* 定义流程中指定的抽象方法，具体细节交给子类去实现 */ abstract void open(); abstract void print(); abstract void close(); }    CharDisplayTemplate类  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class CharDisplayTemplate extends AbstractDisplay { private char aChar; public CharDisplayTemplate(char a) { this.</description>
    </item>
    
  </channel>
</rss>