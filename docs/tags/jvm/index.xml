<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jvm on Quinn</title>
    <link>https://touch-star.com/tags/jvm/</link>
    <description>Recent content in jvm on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 27 Dec 2020 21:10:47 +0800</lastBuildDate>
    
	<atom:link href="https://touch-star.com/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[ Java ] 4-1.关于锁</title>
      <link>https://touch-star.com/post/coding/java/base/4_thread/4_1_locks/</link>
      <pubDate>Sun, 27 Dec 2020 21:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/4_thread/4_1_locks/</guid>
      <description>关于锁 1.自旋锁（SpinLock）  当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断的判断锁是否已经被其他线程释放，可以成功获取到锁，直到可以获取到锁才退出循环。
 无论 自旋锁 ，还是 互斥锁 ， 在任何时刻，都最多只有一个执行单元获得锁。
2.可重复锁/不可重复锁  可重复锁： 广义上定义为，可重复可递归调用的锁，在外层使用之后，在内层依旧可以使用，并且不会发生死锁(前提保证是同一个Obj或Class)。例如：ReentrantLock 和 synchronized 是可重复锁。
 Coding Demo One：
1 2 3 4 5 6 7 8 9  synchronized void setA() throw Exception{ Thread.sleep(1000); // 如果不是可重入锁，setB()将可能不会被当前线程执行，造成死锁。  setB(); } synchronized void setB() throw Exception{ Thread.sleep(1000); }    不可重复锁： 与 可重入锁刚好相反，不可重复进行递归调用，递归调用将造成死锁。
 Coding Demo One：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // 通过 自旋锁 实现一个不可重入锁  public class UnreentrantLock{ private AtomicReference&amp;lt;Thread&amp;gt; owner = new AtomicReference&amp;lt;&amp;gt;(); public void lock(){ Thread curr = Thread.</description>
    </item>
    
    <item>
      <title>[ JVM ] 1.关于JVM命令</title>
      <link>https://touch-star.com/post/coding/java/base/3_jvm/1_jvm-base/</link>
      <pubDate>Sun, 27 Dec 2020 21:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/3_jvm/1_jvm-base/</guid>
      <description>关于JVM命令 一、命令列表  jps jmap jhat jstat jstack jcmd jinfo  二、命令使用 1. jps - JVM进程状态   用法
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  $ jps -help usage: jps [-help] jps [-q] [-mlvV] [&amp;lt;hostid&amp;gt;] Definitions: &amp;lt;hostid&amp;gt;: &amp;lt;hostname&amp;gt;[:&amp;lt;port&amp;gt;] # 若不指定&amp;lt;hostid&amp;gt;,则表示当前默认主机或服务器 # -q 仅输出当前进程号 # -m 输出JVM启动时传递给main()的参数 # -l 输出主类名称；如果进程是jar，将输出jar路径 # -v 输出传递给JVM的参数 # -V 仅输出本地JVM标识符     实例讲解</description>
    </item>
    
    <item>
      <title>[ JVM ] 2.JVM垃圾回收</title>
      <link>https://touch-star.com/post/coding/java/base/3_jvm/2_jvm_gc/</link>
      <pubDate>Sun, 27 Dec 2020 21:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/3_jvm/2_jvm_gc/</guid>
      <description>JVM垃圾回收 1. 垃圾回收机制 在Java中，编写代码时不需要通过显式方式去释放一个对象的内存，而是通过JVM自行进行垃圾回收。JVM中，存在一个垃圾回收线程，它属于一个 低优先级线程 ，正常情况下是不会执行的，只有在 JVM空闲 或者 当前堆内存不足 时，才会触发执行，扫描那些 没有被任何引用的对象 ，并将它们添加到回收集合中，进行内存释放。
2. 引用类型   强引用
发生GC时，对象不会被回收。
  软引用
有用但不是必须的对象，在发生内存溢出之前会被回收
  弱引用
有用但不是必须的对象，在下一次GC时会被回收
  虚引用
无法通过虚引用获取到对象(通过 PhantomReference 实现虚引用)，作用是在GC时返回一个通知。
  3. 如何判断对象是否可以被回收？ 垃圾收集器在做垃圾回收的时候，首先需要判定的就是 哪些对象内存需要被释放 ， 哪些对象依旧存活，不可释放 。
一般通过两种方式进行判断：
  引用计数器法：
为每一个对象创建一个引用计数，有对象引用时计数器进行 ++ ，应用被释放时计数 &amp;ndash; ，当 计数器==0 时可以被回收。(不足： 无法解决循环引用问题)
  可达性分析算法：
从 GC Roots 开始向下搜索，搜索所走过的路径成为引用链。当一个对象到 GC Roots没有任何引用链是，则可以进行回收。
  4. 在Java中，对象什么时候可以被进行垃圾回收？  当对象对当前使用这个对象的应用程序 变得不可触及 的时候，这个对象就可以进行垃圾回收。 垃圾回收不会发生在永久代，如果 永久代满了 或者 超出了临界值，会触发完全垃圾回收(FGC)。 查看垃圾收集器的输出信息，可以发现永久代也是会被回收的，这就是为什么正确的永久代大小对避免FGC是非常重要的原因。  5.</description>
    </item>
    
    <item>
      <title>[ JVM ] 3.JVM内存模型</title>
      <link>https://touch-star.com/post/coding/java/base/3_jvm/3_jvm_memory_monitor/</link>
      <pubDate>Sun, 27 Dec 2020 21:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/3_jvm/3_jvm_memory_monitor/</guid>
      <description>JVM内存 1. 简述Java内存分配与回收策略 2. Minor GC 与 Major GC   Minor GC： 又称 新生代GC
Java对象大多数是朝生夕灭，所以 Minor GC 非常频繁，一般回收速度也比较快
  Major GC： 又称 老年代GC
指发生在 老年代 的GC。出现 FGC 经常会伴有 至少一次的 Minor GC(不是绝对，Parallel Scavenge收集器可以选择Major GC策略)。Major GC 一般比 Minor GC 慢上 10倍以上
  3. Java中 堆 和 栈 的区别 JVM中 堆 和 栈 是不同的内存区域，使用目的也不同。
 栈  用于 保存方法帧 和 局部变量 不会在多个线程之间进行共享，即 线程私有 栈不足，产生异常错误是、：java.lang.StackOverFlowError   堆：  Java 对象 始终在堆上分配 堆将会被整个JVM的所有线程进行共享，即 所有线程共有 堆不足，产生异常错误：java.</description>
    </item>
    
    <item>
      <title>[ JVM ] 4.JVM类加载机制</title>
      <link>https://touch-star.com/post/coding/java/base/3_jvm/4_jvm_class_loader/</link>
      <pubDate>Sun, 27 Dec 2020 21:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/3_jvm/4_jvm_class_loader/</guid>
      <description>JVM类加载机制 1. Java类加载机制 JVM中类的装载是由
2. 描述JVM加载Class文件的原理机制 3. 什么是类加载器？类加载器又有哪些？   启动类加载器(Bootstrap ClassLoader)：
负责加载${JAVA_HOME}/lib目录下或通过-Xbootclasspath参数指定路径中被JVM认可的类
  扩展类加载器(Extension ClassLoader)：
负责加载${JAVA_HOME}/lib/ext目录中或通过java.ext.dirs系统变量指定路径中的类库
  应用程序类加载器(Application ClassLoader)：
负责加载用户路径classpath下的类库。JVM通过 双亲委派模型 进行类的加载，也可通过 继承 java.lang.ClassLoader 实现自定义的类加载器。
  4. 类装载的执行过程。 5. 什么是双亲委派模型？  当一个类收到 类加载请求 ，首先不去尝试自己加载此类，而是把此请求 委派 父类去完成； 每一个层次类加载器都是如此，因此所有的加载请求都应该传送到 启动类加载器 中； 只有当 父类加载器 反馈无法完成此请求是，子类加载器 才会尝试自己加载。   采用双亲委派的一个好处： 加载位于rt.jar包中的类 java.lang.Object，不管是哪个类加载器加载的这个类，最终都将委托给顶层的 启动类加载器 进行加载，即可以保证使用不同的类加载器，也能保证加载的都是同一个Object对象。
 </description>
    </item>
    
  </channel>
</rss>