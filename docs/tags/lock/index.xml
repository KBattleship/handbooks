<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lock on Quinn</title>
    <link>https://touch-star.com/tags/lock/</link>
    <description>Recent content in Lock on Quinn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 10 Jan 2021 11:10:47 +0800</lastBuildDate>
    
	<atom:link href="https://touch-star.com/tags/lock/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[ Java ] 4-2.JUC之AQS</title>
      <link>https://touch-star.com/post/coding/java/base/4_thread/4_2_aqs/</link>
      <pubDate>Sun, 10 Jan 2021 11:10:47 +0800</pubDate>
      
      <guid>https://touch-star.com/post/coding/java/base/4_thread/4_2_aqs/</guid>
      <description>JUC之AQS 1.基础知识 1_1. AQS原理 AQS(AbstractQueuedSynchronizer),是java.util.concurrent.locks下的一个普通类。用作构建 锁 和 同步器 框架。例如基于AQS构建的有：ReentrantLock, Semaphore, ReentrantReadWriteLock, SynchronousQueue, FutureTask 等等。
核心思想：
 如果被请求的共享资源处于 空闲状态 ，则将当前请求资源的线程设置为 有效的工作线程 ，并且将共享资源设置为 锁定状态。 如果被请求的共享资源处于 占用状态 ，则需要一套 线程阻塞等待 以及 被唤醒时锁分配 的流程机制。 AQS 通过 CLH (Craig, Landin, Hagersten) 队列锁实现：将暂时获取不到锁的线程加入至队列中。 AQS使用一个 int 成员变量来标识同步状态，通过内置的 FIFO 队列完成获取资源线程的排队工作，使用 CAS(compare and swap) 对改状态进行原子操作实现对其值的更改。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  // 共享变量，使用volatile修饰符保证线程可见性 private volatile int state; /** 状态信息通过protected修饰符修饰 getState(), setState(), compareAndSetState()进行操作 */ // 返回同步状态的当前值 protected final int getState(){ return state; } // 设置同步状态当前值 protected final void setState(int newState){ this.</description>
    </item>
    
  </channel>
</rss>