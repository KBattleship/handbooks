---
title: "[ Interview ] 3. 面试之Java"
date: 2021-01-08T01:13:47+08:00
lastmod: 2021-01-08T01:13:47+08:00
keywords: ['interview']
description: ""
tags: ['interview','面试','algorithm']
categories: ['Algorithm']
author: ""
---
# 面试

## X_Q

### 1.JVM垃圾回收机制

Java编程中，程序员不需要刻意显式进行垃圾回收去释放一个对象内存，而是JVM会进行自动垃圾回收。
JVM中存在一个 **`优先级较低`** 的线程，只有当 **`JVM处于空闲`** 或者 **`堆空间不足`** 的情况触发执行。此过程中，将扫描到 **没有被引用的对象** 防止垃圾回收集合中，进行垃圾回收。

+ **`判断对象是否可以被回收`**
  + 引用计数器：

    + 为每一个对象创建一个引用计数器，有引用此对象，计数器进行+1；引用释放后，计数器进行-1。当对象引用计数器 == 0时，说明此对象可以进行回收。(**不能解决循环引用问题**)
  + 可达性分析算法

    + 从GC Roots开始向下搜索，走过的搜索路径将形成引用链，当一个对象到 **GC Roots**不存在任何引用链式，说明此对象可以进行回收。

### 2.什么是Netty？

> 见 [Netty](/post/middleware/netty/6_1_netty)

### 3.Netty粘包/拆包

### 3.Kubernetes工作原理

### 4.快排实现原理


## B_D

### 1. Hash最终一致性算法

+ **算法目标：**
    
    当`K`个Key的请求时，后台增减节点，只会引起 **K/N** 的 Key发生重新映射。
    - 在后台节点稳定时，同一个key的每次请求映射到的节点是一样的。
    - 在后台节点增减时，此算法尽量将 **K** 个Key映射到之前相同的节点上。
+ **Hash存在问题：**
  - 假定N为后台服务节点数，当前台携带关键字key发出请求时，我们通常将key进行Hash后采用 **`模运算(hash(key)%N)`** 来讲请求分发在不同的节点上。
  - 对前台请求于`后台无状态服务节点`不敏感的场景而言，只要请求key具有一定的随机性，哪怕节点动态增删，该算法对于后台而言一样可以起到很好的负载均衡效果。
  - 但在对于`分布式缓存`，或者`分布式数据`这样`有状态服务`的情况下，上述方式将存在问题。因为后台节点的增删会引起几乎所有的Key的重新映射：
    - 针对分布式缓存而言，均发生cache miss；
    - 针对分布式数据库而言，发生数据错乱的情况，影响都是灾难性的。
+ **判断标准：**
    - 平衡性(Balance)：指哈希的结果能够尽可能分不到所有的缓冲中，这样可以使得所有缓冲空间都得到利用。
    - 单调性(Monotonicity)：单调性是指如果已经有一些内容通过Hash算法分配到了缓冲中，又有新的缓冲加入到系统中，Hash的结果应该能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
    - 分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲。不同的终端可能通过Hash的过程将同样的缓冲内容应设在不同的缓冲中。`应尽量降低分散性`。
    - 负载(Load)：实际上是另一个角度看待分散性。对于一个特定的缓冲区而言，可能被不同的用户映射到不同的内容。`应尽量降低缓冲的负荷`。
+ **Hash一致性算法：**
    - 是一个2^32个点组成的Hash圆环
    - 按照 **顺时针方向** 进行组织
    - 将数据 **Key** 使用相同的 `hash()` 计算出Hash值，并确定在此 Hash环 上的位置，从此位置按照 **顺时针方式** 寻找，碰到的第一台节点将是定位到的节点。
+ **Hash环发生数据倾斜**
  + 在服务节点太少的情况，数据容易发生倾斜
  + 解决办法：
    + 增加虚拟节点，形成均匀的Hash环避免数据倾斜。
    + 通过 **Hash("${Node1}#1")** 的方式构造成虚拟节点。


### 2. TCP与UDP的区别
+ TCP
  + 面向有连接
    - 发送数据前两端必须进行连接。因 **三次握手** 建立连接，使得数据传输更加可靠
  - 仅支持单播方式
  - 面向字节流
    - 不保留报文边界，通过字节流的方式进行传输
  - 可靠传输
    - 为保证可靠传输，每个包都拥有序号，同时保证包传输的顺序性也保证包的完整性。
    - 接收端接收到数据后需要返回确认帧，如果在规定时延内发送端未收到确认帧，将视为丢包进行重传。
  - 拥塞机制
    - 在网络出现拥塞的情况下，TCP可以减小向网络注入数据的速率和数量，缓解拥塞
  - 提供全双工通信
    - 通讯双方的应用程序在任何时候都能发送数据
+ UDP
  + 面向无连接
  + 支持单播、多播、广播方式
  + 面向报文
    + UDP对应用成交付的报文不合并不拆分，而是保留报文的边界，应用程序必须要控制合适的报文大小。
  + 不可靠性
    + 通信不需要建立连接。想发就发，并且不关心对方接收到的数据是否正确无误
    + 没有拥塞控制，可能出现丢包情况。
  + 头部数据小，数据传输高效。
### 3. TCP如何保证网络安全的

> `  即TCP的特性`


### 4. TCP三次握手
+ 第一次握手
  + 客户端 向 服务端 发出连接请求的报文，请求发送成功后，客户端进入 `SYN-SENT` 状态
+ 第二次握手
  + 服务端 收到 客户端 连接请求的报文后，如同意连接，发出一个应答，发送完成后进入 `SYN-RECEIVED` 状态
+ 第三次握手
  + 当 客户端 收到连接同意的应答后，需向服务端发送一个确认报文。发送完成后，客户端进入 `ESTABLISHED` 状态， 服务端 收到这个确认应答后也将进入 `ESTABLISHED`

### 5. TCP四次挥手
（1）：客户端发送终止命令FIN

（2）：服务端收到后回复ACK，处于close_wait状态

（3）：服务器将关闭前需要发送信息发送给客户端后处于last_ack状态

（4）：客户端收到FIN后发送ack后处于tim-wait而后进入close状态
### 5. Kubernetes中Pod间如何通讯的

> 通过 `CNI`(Container Network Interface) 进行网络通讯。

### 6. Mysql索引

> [Mysql索引](/post/middleware/database/sql/mysql/2_2_sql_index)

### 7. Mysql B+ Tree索引实现原理

### 8. Zookeeper在Kafka中的作用

+ Broker注册

    分布式下的Broker之间相互独立，需要一个注册中心将其Broker集群管理起来，Zookeeper将会对Broker集群列表进行记录。
+ Topic注册

    同一个Topic的消息会被分成多个分区分散在不同的Broker，Zookeeper将会维护分区信息以及与broker之间对应关系。

+ 负责Producer、Consumer负载均衡
  
  Zookeeper通过负载均衡，协助Producer、Consumer将消息合理的发送或消费到指定的Broker。

+ 分区与Consumer的关系
  
    每一个消费者一旦确定一个消息分区的消费能力，需要将其对应信息写入至Zookeeper对应消息分区的临时节点上。

+ 记录Consumer消费进度Offset

    在Consumer对指定消息分区进行消费的过程中，会定时将分区消息的Offset记录到Zookeeper上。以便此消费者重启或变更其他消费者消费时再次继续进行消费。

### 9. 有没有做过DockerImage精简
### 10. 服务是如何在服务器运行的，如何实现发布DockerImage发布的
