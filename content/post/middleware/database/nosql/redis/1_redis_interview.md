---
title: "[ Redis ] 1. Redis"
date: 2020-01-06T01:13:47+08:00
lastmod: 2020-01-06T01:13:47+08:00
keywords: ['redis']
description: ""
tags: ['middleware','redis','缓存']
categories: ['MiddleWare']
author: ""
---


# Redis

## 1. 什么是跳表

  + 跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他的几点指针，从而达到快速访问队尾目的。跳跃表的效率可以和平衡树想媲美了，最关键是它的实现相对于平衡树来说，代码的实现上简单很多
  + 跳跃表 level 层级完全是随机的。一般来说，层级越多，访问节点的速度越快。
  + 一是实现有序集合键，二是集群节点中用作内部数据结构。
  + 相比于红黑树、平衡二叉树，跳表不仅查找、插入、删除时间复杂度都是O(logN)，并且实现简单很多。

## 2. Redis中BitMap

+ Bitmap并不是一种独立的数据结构，而是基于String数据结构进行的位图操作。
    + 最大空间即为String数据结构所支持的512MB，
    + 所以bitmap所支持的最大offset为2^32-1.

+ 一般使用场景用于大数据签到、日活统计、在线统计等等。
  + 其主要优点可以节省大量空间。
  + 例如：
    进行日活统计：
    + 使用日期作为key，用户ID作为偏移量，1为当日活跃，0为不活跃
```shell
  ### 基本操作演示(以下为Redis-cli命令)
  
  # 设置一个字符串 1Aa 
  # 存储在redis中的二进制为 0b001100010100000101100001
  set testkey 1Aa

  # 进行bitmap操作
  setbit testkey 10 1
  setbit testkey 18 0

  # testkey对象index为10的bit值为1
  getbit testkey 10 
  # testkey对象index为18的bit值为1
  getbit testkey 18

  # 进行位统计 ,结果为bit上为1的和，
  # testkey输出结果为 8
  bitcount testkey

  # testkey输出结果为 3
  bitcount testkey 0 0
  ```

## 3. redis事务
+ Multi开启事务

+ Exec执行事务块内命令

+ Discard 取消事务

+ Watch 监视一个或多个key，如果事务执行前key被改动，事务将打断

## 4. Redis的同步机制
+ 全量拷贝， 
  + 1.slave第一次启动时，连接Master，发送PSYNC命令，
  + 2.master会执行bgsave命令来生成rdb文件，期间的所有写命令将被写入缓冲区。
    + master bgsave执行完毕，向slave发送rdb文件
    + slave收到rdb文件，丢弃所有旧数据，开始载入rdb文件
    + rdb文件同步结束之后，slave执行从master缓冲区发送过来的所以写命令。
  + 此后 master 每执行一个写命令，就向slave发送相同的写命令。
+ 增量拷贝 
  + 如果出现网络闪断或者命令丢失等异常情况，从节点之前保存了自身已复制的偏移量和主节点的运行ID
  + 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。

## 5. 缓存淘汰策略
（1）：先进先出算法（FIFO）

（2）：最近使用最少Least Frequently Used（LFU）

（3）：最长时间未被使用的Least Recently Used（LRU）

当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重

## 6.redis过期key删除策略
（1）：惰性删除，cpu友好，但是浪费cpu资源

（2）：定时删除（不常用）

（3）：定期删除，cpu友好，节省空间

## 7.缓存击穿原因以及处理办法
频繁请求查询系统中不存在的数据导致；

+ 处理方法：
  + cache null策略，查询反馈结果为null仍然缓存这个null结果，设置不超过5分钟过期时间
  + 布隆过滤器，所有可能存在的数据映射到足够大的bitmap中 google布隆过滤器：基于内存，重启失效不支持大数据量，无法在分布式场景 redis布隆过滤器：可扩展性，不存在重启失效问题，需要网络io，性能低于google

## 8.缓存雪崩以及处理办法
同一时刻大量缓存失效；

处理方法：

（1）：缓存数据增加过期标记

（2）：设置不同的缓存失效时间

（3）：双层缓存策略C1为短期，C2为长期

（4）：定时更新策略

## 9.Redis如何做持久化
bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据 ，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来 实 现完整恢复重启之前的状态。


## bgsave的原理是什么？
fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写进的页面数据会逐渐和子进程分离开来。

## RDB与AOF区别
（1）：R文件格式紧凑，方便数据恢复，保存rdb文件时父进程会fork出子进程由其完成具体持久化工作，最大化redis性能，恢复大数据集速度更快，只有手动提交save命令或关闭命令时才触发备份操作；

（2）：A记录对服务器的每次写操作（默认1s写入一次），保存数据更完整，在redis重启是会重放这些命令来恢复数据，操作效率高，故障丢失数据更少，但是文件体积更大；

## redis如何实现延时队列？
使用sortedset，想要执行时间的时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。

## 为啥redis zset使用跳跃链表而不用红黑树实现?
（1）：skiplist的复杂度和红黑树一样，而且实现起来更简单。

（2）：在并发环境下红黑树在插入和删除时需要rebalance，性能不如跳表。