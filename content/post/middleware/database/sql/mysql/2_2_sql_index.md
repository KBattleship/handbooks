---
title: "[ MySQL ] 2.MySQL索引"
date: 2020-01-06T01:13:47+08:00
lastmod: 2020-01-06T01:13:47+08:00
keywords: ['mysql']
description: ""
tags: ['middleware','mysql','index','索引']
categories: ['MiddleWare']
author: ""
---

# MySQL索引

> Index(索引)，在存储引擎中用于快速找到记录的一种数据结构。索引用来快速寻找特定值的记录。

如果没有索引，执行查询时，MySQL必须从第一个记录开始扫描整个表的所有记录，知道找到符合要求的记录。<br/>
如果存在索引，MySQL无需扫描全表即可迅速查找到目标记录所在的位置。

## 1. 索引类型

+ Hash索引：
  + 底层实现是基于哈希表，是一种以Key-Value形式存储数据的结构。
  + 多个数据在存储关系上是没有任何顺序关系的。对于区间查询是无法通过索引查询的，
  + 只能通过全表扫描的方式进行。Hash索引适用于等值查询场景。

+ B+ Tree索引：(MySQL引擎Innodb实现方式)
  + B+ Tree索引是一种多路平衡查询树。
  + 其节点是天然有序的(左节点 < 父节点 < 右节点)。
  + 对于范围查询时候不需要做全表扫描。

+ 相比Hash索引，B+ Tree的优点：
  1. Hash索引适合等值查询，但是无法进行范围查询 
  2. Hash索引没办法利用索引完成排序 
  3. Hash索引不支持多列联合索引的最左匹配规则 
  4. 如果有大量重复键值的情况下，Hash索引的效率会很低，因为存在Hash碰撞问题

## 2. MySQL索引失效的几种情况
  + 如果条件中有or，即使其中有条件带索引也不会使用
  + 对于多列索引，不是使用的第一部分(第一个)，则不会使用索引
  + like查询是以%开头
  + 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
  + 如果mysql估计使用全表扫描要比使用索引快,则不使用索引
  + not in ,not exist.
  + 范围查询

## 索引的底层实现是B+树，为何不采用红黑树，B树?
（1）：B+Tree非叶子节点只存储键值信息，降低B+Tree的高度，所有叶子节点之间都有一个链指针，数据记录都存放在叶子节点中

（2）： 红黑树这种结构，h明显要深的多，效率明显比B-Tree差很多

（3）：B+树也存在劣势，由于键会重复出现，因此会占用更多的空间。但是与带来的性能优势相比，空间劣势往往可以接受，因此B+树的在数据库中的使用比B树更加广泛

## 七种事务传播行为
（1）Propagation.REQUIRED<默认> 如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。

（2）Propagation.SUPPORTS 如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。

（3）Propagation.MANDATORY 如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。

（4）Propagation.REQUIRES_NEW 重新创建一个新的事务，如果当前存在事务，延缓当前的事务。

（5）Propagation.NOT_SUPPORTED 以非事务的方式运行，如果当前存在事务，暂停当前的事务。

（6）Propagation.NEVER 以非事务的方式运行，如果当前存在事务，则抛出异常。

（7）Propagation.NESTED 如果没有，就新建一个事务；如果有，就在当前事务中嵌套其他事务。



## 3. 强制索引

```sql
# 强制索引
select * from table force index(PRI) limit 2;

# 禁止索引
select * from table ignore index(PRI) limit 2;
```