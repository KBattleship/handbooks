---
title: "[ JVM ] 2.JVM垃圾回收"
date: 2020-12-27T21:10:47+08:00
lastmod: 2020-12-27T21:10:47+08:00
keywords: ['jvm']
description: ""
tags: ['java','jvm','command']
categories: ['Java']
author: ""
---
# JVM垃圾回收

## 1. 垃圾回收机制

 在Java中，编写代码时不需要通过显式方式去释放一个对象的内存，而是通过JVM自行进行垃圾回收。JVM中，存在一个垃圾回收线程，它属于一个 **低优先级线程** ，正常情况下是不会执行的，只有在 **JVM空闲** 或者 **当前堆内存不足** 时，才会触发执行，扫描那些 **没有被任何引用的对象** ，并将它们添加到回收集合中，进行内存释放。
## 2. 引用类型

+ 强引用

  发生GC时，对象不会被回收。
+ 软引用

    有用但不是必须的对象，在发生内存溢出之前会被回收
+ 弱引用

    有用但不是必须的对象，在下一次GC时会被回收
+ 虚引用

    无法通过虚引用获取到对象(通过 **PhantomReference** 实现虚引用)，作用是在GC时返回一个通知。

## 3. 如何判断对象是否可以被回收？

垃圾收集器在做垃圾回收的时候，首先需要判定的就是 ***哪些对象内存需要被释放*** ， ***哪些对象依旧存活，不可释放*** 。

一般通过两种方式进行判断：

  + **引用计数器法**：
    
    为每一个对象创建一个引用计数，有对象引用时计数器进行 **++** ，应用被释放时计数 **--** ，当 **计数器==0** 时可以被回收。(不足： **无法解决循环引用问题**)
    
  + **可达性分析算法**：
    
    从 **GC Roots** 开始向下搜索，搜索所走过的路径成为引用链。当一个对象到 GC Roots没有任何引用链是，则可以进行回收。
    + 1：系统类加载器加载的对象

    + 2：处于激活状态的线程

    + 3：JNI栈中的对象

    + 4：正在被用于同步的各种锁对象

    + 5：JVM自身持有的对象，比如系统类加载器等。

## 4. 在Java中，对象什么时候可以被进行垃圾回收？

1. 当对象对当前使用这个对象的应用程序 **变得不可触及** 的时候，这个对象就可以进行垃圾回收。
2. 垃圾回收不会发生在永久代，如果 **永久代满了** 或者 **超出了临界值**，会触发完全垃圾回收(FGC)。
`查看垃圾收集器的输出信息，可以发现永久代也是会被回收的，这就是为什么正确的永久代大小对避免FGC是非常重要的原因。`

## 5. JVM中永久代会发生GC吗？
垃圾回收不会发生在永久代。如果 **永久代满了** 或者 **超出了临界值**，会触发完全垃圾回收(FGC)。

`JDK8 中移除了永久代，新增加了元数据区的Native内存区`

## 6. 垃圾回收算法

+ **标记-清除算法：** 标记无用对象，然后进行清除回收。(缺点：效率低，无法清除垃圾碎片)
+ **复制算法：** 按照容量划分两个大小相等的内存区域，当一块用完之后将活着的对象移动至另外一块，然后再把已使用的内存空间一次性释放掉。(缺点：内存使用率低，只有原来的一半)
+ **标记-整理算法：** 标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉边界以外的内存。
+ **分代算法：** 根据对象存活周期的不同将内存划分为几块(一般情况是新生代、老生代)，新生代采用复制，老年代采用标记-整理算法。

## 7. 垃圾回收器
用于新生代的收集器：Serial、PraNew、 ParallelScavenge
用于老年代的收集器：Serial Old、Parallel Old、CMS
用于回收整个堆的：G1
+ **Serial(复制算法)：** 新生代单线程收集器，标记-清理都是单线程，简单高效
+ **ParNew(复制算法)：** 新生代并行收集器，实际上Serial收集器的多线程版本。在多核CPU下比Serial具有更好表现
+ **ParallelScavenge(复制算法)：** 新生代并行收集器，追求高吞吐量，高效利用CPU。
+ **Serial Old(标记-整理)：** 老年代单线程收集器
+ **Parallel Old(标记-整理)：** 老年代并行收集器，吞吐量优先，ParallelScavenge的老年代版本。
+ **CMS(Concurrent Mask Sweep，标记-清除)：** 老年代并行收集器，以获取最短回收停顿时间为目，具有高并发、低停顿的特点。追求最短GC回收停顿时间。
+ **G1(Garbage First，标记-整理)：** Java堆并行收集器，始于JDK1.7，G1是基于标记-整理算法实现，不会产生垃圾碎片。此外，重要的特点：G1回收的范围是整个Java堆，而前几种回收范围仅限于 新生代 或 老年代。

## 8. 关于CMS垃圾回收器

**CMS垃圾回收器(Concurrent Mask Sweep)** ，是以牺牲吞吐量为代价来获取最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用，此垃圾回收器很适合。
`使用CMS回收器方法：`
```shell
# 在JVM启动参数增加此参数项：
 -XX:+UseConcMaskSweepGC
```

## 9. 新生代垃圾回收器与老年代垃圾回收器有哪些？区别是什么？

+ 新生代垃圾回收器一般采用：**复制算法**。优点：效率高；缺点：使用率低。
+ 老生代垃圾回收器一般采用：**标记-整理**。

## 10. 简述分代垃圾回收器是如何工作的。
